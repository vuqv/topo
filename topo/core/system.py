#!/usr/bin/env python
# coding: utf-8
# import os
from collections import OrderedDict

import numpy as np
import openmm as mm
import openmm.unit as unit
import parmed as pmd
import warnings
from ..parameters import model_parameters


# from openmm import *
# from openmm.app import *


class system:
    """

    A class for generating coarse-grained (CG) systems that can be simulated using the OpenMM interface.
    It allows for the creation of both default and custom CG systems and easy modification of their parameters.

    Parameters
    ----------
        structure_path : str
            The path to the input PDB or CIF file. Required.
        model: str, optional, default='topo'
            The model to be used. Currently only 'topo' (topology-based for folded proteins) is supported.

    Attributes
    ----------

    structure : :class:`mm.app.pdbfile.PDBFile` or :class:`mm.app.pdbxfile.PDBxFile`
            An object that holds the information of the parsed PDB or CIF file.
    topology : :class:`mm.app.topology.Topology`
            The topology of the model, as generated by OpenMM.
        positions : :class:`unit.quantity.Quantity`
            The atomic positions of the model.
        particles_mass : float or list
            The mass of each particle. If a float is provided, all particles will have the same mass.
            If a list is provided, per-particle masses will be assigned.
        particles_charge : list
            The charge of each particle.
    rf_sigma : float
            The sigma parameter used in the pairwise force object. This is the vdw radius of beads.
    atoms : list
        A list of the current atoms in the model. The items are :class:`mm.app.topology.atoms`
        initialised classes.
    n_atoms : int
        The total number of atoms in the model.
    bonds : :class:`collections.OrderedDict`
        A dictionary that uses bonds (2-tuple of :class:`mm.app.topology.bonds` objects)
        present in the model as keys and their forcefield properties as values.
    bonds_indexes : list
        A list containing the zero-based indexes of the atoms defining the bonds in the model.
    n_bonds : int
        The total number of bonds in the model.
    bonded_exclusions_index : int
        The exclusion rule for nonbonded force.
        =3 for topo model (bonded exclusions for angles/torsions)
    harmonicBondForce : :class:`mm.HarmonicBondForce`
        The :class:`mm.HarmonicBondForce` object that implements
        a harmonic bond potential between pairs of particles, that depends
        quadratically on their distance.
    n_angles : int
        The total number of angles in the model.
    gaussianAngleForce : :class:`mm.CustomAngleForce`
        The :class:`mm.CustomAngleForce` object that implements
        a Gaussian angle bond potential between pairs of three particles.
    n_torsions : :code:`int`
        Total number of torsion angles in the model.
    gaussianTorsionForce : :code:`mm.CustomTorsionForce`
        Stores the OpenMM :code:`CustomTorsionForce` initialised-class. Implements
        a Gaussian torsion angle bond potential between pairs of four particles.
    yukawaForce : :code:`mm.CustomNonbondedForce`
        Stores the OpenMM :code:`CustomNonbondedForce` initialized-class.
        Implements the Debye-Huckle potential.
    ashbaugh_HatchForce : :code:`mm.CustomNonbondedForce`
        Stores the OpenMM :code:`CustomNonbondedForce` initialized-class. Implements the pairwise short-range
        potential.
    forceGroups : :code:`collections.OrderedDict`
        A dict that uses force names as keys and their corresponding force
        as values.
    system : :code:`mm.System`
        Stores the OpenMM System initialised class. It stores all the forcefield
        information for the topo model.


    Methods
    -------


    loadForcefieldFromFile()
        Loads forcefield parameters from a force field file written with
        the :code:`dumpForceFieldData()` method.

    """

    # def __init__(self, structure_path, model):
    def __init__(self, structure_path: str, model: str = 'hps_urry'):
        """
        Initialises the TOPO OpenMM system class.

        Parameters
        ----------
        structure_path : string [requires]
            Name of the input PDB or CIF file
        model: str [optional, default='topo']
            Model name. Currently only 'topo' is supported.
        Returns
        -------
        None
        """

        # Define structure object attributes

        self.structure_path = structure_path
        # Recognize format of input structure file
        if structure_path.endswith('.pdb'):
            self.structure = mm.app.PDBFile(structure_path)
        elif structure_path.endswith('.cif'):
            self.structure = mm.app.pdbxfile.PDBxFile(structure_path)
        else:
            raise ValueError(
                'Structure file extension not recognized. It must end with .pdb or .cif accordingly.')
        self.topology = self.structure.topology
        self.positions = self.structure.positions

        self.model = model
        # particle properties
        self.particles_mass = None
        self.rf_sigma = None  # particle vdw radius
        self.particles_charge = None
        self.particles_hps = None  # hydropathy scale of particles
        self.particle_type_id = None

        # Define geometric attributes
        self.atoms = []
        self.n_atoms = None

        self.chains = []
        self.n_chains = None

        self.bonds = OrderedDict()
        self.bonds_indexes = []
        self.n_bonds = None
        self.bond_length_protein = model_parameters.parameters[model]["bond_length_protein"]
        self.bond_length_nucleic = model_parameters.parameters[model]["bond_length_nucleic"]
        self.bondedTo = None
        self.harmonicBondForce = None

        self.angles = OrderedDict()
        self.angles_indexes = []
        self.n_angles = None
        self.gaussianAngleForce = None

        self.torsions = OrderedDict()
        self.torsions_indexes = []
        self.n_torsions = None
        self.gaussianTorsionForce = None
        self.periodicTorsionForce = None

        # Exclusion rule for nonbonded forces
        self.bonded_exclusions_index = model_parameters.parameters[model]["bonded_exclusions_index"]

        # Parameters for PairWise potential Force
        self.ashbaugh_HatchForce = None

        # instance for Wang-Frenkel potential, alternative to Ashbaugh_Hatch
        self.wang_Frenkel_Force = None

        self.custom_non_bonded_force = None

        # Define parameters for DH potential Force
        self.yukawaForce = None

        self.forceGroups = OrderedDict()

        # Initialise an OpenMM system class instance
        self.system = mm.System()

    def getCAlphaOnly(self) -> None:
        """
        Filter in only alpha carbon atoms from the input structure and updates
        the topology object to add new bonds between them. Used specially for
        creating alpha-carbon (CA) coarse-grained models.

        Keeps in the :code:`topo system` only the alpha carbon atoms from the :code:`OpenMM topology`.

        @TODO:
        check for residues indices are consecutive:

        # psedo-code
        np_indices = np.array(atom_indices)
        if len(np_indices) > 1:
            if (np_indices[1:] - np_indices[:-1]) SOME_CONDITION_TO_CHECK_FOR_CONSECUTIVE:
                warnings.warn('atom indices are not monotonically increasing')
            if len(np.unique(np_indices)) < len(np_indices):
                warnings.warn('atom_indices are not unique')

        Parameters
        ----------


        Returns
        -------
        None
        """

        # save all non C-alpha atoms
        atoms_to_remove = []
        # oldIndex = []
        for a in self.topology.atoms():
            if a.name != 'CA':
                atoms_to_remove.append(a)

        # Remove all non C-alpha atoms
        modeller_topology = mm.app.modeller.Modeller(self.topology, self.positions)
        modeller_topology.delete(atoms_to_remove)
        self.topology = modeller_topology.getTopology()
        self.positions = modeller_topology.getPositions()

        chains = []
        for chain in self.topology.chains():
            chains.append(chain)
            # self.n_chains += 1

        self.n_chains = 0
        for chain in chains:
            self.chains.append(chain)
            self.n_chains += 1

        """
            Update system atoms, then add bonds between C-alpha atoms of the same chain.
            openMM load input PDB file and separate chain if encounter TER instruction. It doesn't matter if two chains
            have the same chain name.
            This may have a vulnerable is that if two CA atom on the same chain not consecutive, like residue
            8 and 10 are listed consecutively on input file but residue 9 was missing. The code will add bond between
            residue 8 and 10 which cause large bond. The better solution is check the input file carefully and the logic
            condition in code has nothing to do.
        """
        atoms = list(self.topology.atoms())
        for i in np.arange(1, len(atoms)):
            if atoms[i].residue.chain == atoms[i - 1].residue.chain:
                self.topology.addBond(atoms[i - 1], atoms[i])

    def getAtoms(self):
        """
        Reads atoms from topology, adds them to the main class and sorts them
        into a dictionary to store their forcefield properties.

        After getCAlphaOnly, C-alpha atoms are stored on :code:`self.topology only`.
        We need to add them to atoms attribute and system also.
        Adds :code:`atoms` in the :code:`OpenMM topology` instance to the :code:`TOPO system` class.

        Parameters
        ----------

        Returns
        -------
        None
        """

        # Get Atoms From Topology
        atoms = []
        for atom in self.topology.atoms():
            atoms.append(atom)

        # Sort atoms by index
        atoms = sorted(atoms, key=lambda x: x.index)

        # Add atoms to topo object
        self.n_atoms = 0
        for atom in atoms:
            self.atoms.append(atom)
            self.n_atoms += 1

    def getBonds(self, except_chains=None):
        """
        Reads bonds from topology, adds them to the main class and sorts them
        into a dictionary to store their forcefield properties.

        Adds :code:`bonds` in the :code:`OpenMM topology` instance to the :code:`TOPO system` class.

        Parameters
        ----------
        except_chains: String [optional]

        Returns
        -------
        None
        """

        if isinstance(except_chains, str):
            except_chains = list(except_chains)

        # Get Bonds From Topology
        bonds = []
        for bond in self.topology.bonds():
            if except_chains is not None:
                if bond[0].residue.chain.id not in except_chains:
                    if bond[1].residue.chain.id not in except_chains:
                        if bond[0].index > bond[1].index:
                            bonds.append((bond[1], bond[0]))
                        else:
                            bonds.append((bond[0], bond[1]))
            else:
                if bond[0].index > bond[1].index:
                    bonds.append((bond[1], bond[0]))
                else:
                    bonds.append((bond[0], bond[1]))

        # Sort bonds by index of first atom
        bonds = sorted(bonds, key=lambda x: x[0].index)

        # Add bonds to topo object
        self.n_bonds = 0
        for bond in bonds:
            """
            TODO: Currently this is bond length for protein. Need to deal with system of Protein+DNA+RNA complexes.
            if bond[0].name in protein_list and bond[1] in protein_list:
                self.bonds[bond] = (bond_length_protein, None)
            elif bond[0].name in nucleic_list and bond[1] in nucleic_list:
                self.bonds[bond] = (bond_length_nucleic, None)
            """

            is_protein_connect = all(bond[i].residue.name in model_parameters.protein_list for i in [0, 1])
            bond_length = self.bond_length_protein if is_protein_connect else self.bond_length_nucleic
            # print(bond_length)
            bond_length = bond_length * unit.nanometer
            self.bonds[bond] = (bond_length, None)
            self.n_bonds += 1

            # Store bond indexes
            self.bonds_indexes.append((bond[0].index,
                                       bond[1].index))

        # Record which atoms are bonded to each other
        self.bondedTo = {}
        for atom in self.topology.atoms():
            self.bondedTo[atom] = []
        for bond in self.topology.bonds():
            self.bondedTo[bond[0]].append(bond[1])
            self.bondedTo[bond[1]].append(bond[0])

    def getAngles(self):
        """
        Reads bonds from topology, adds them to the main class and sorts them
        into a dictionary to store their forcefield properties.

        Angles are built from bond (bondedTo instance).
        This function modify :code:`self.angles`, :code:`self.angles_indexes` and :code:`self.n_angles`
        """
        unique_angles = set()
        for bond in self.bonds:
            for atom in self.bondedTo[bond[0]]:
                if atom != bond[1]:
                    if atom.index < bond[1].index:
                        unique_angles.add((atom, bond[0], bond[1]))
                    else:
                        unique_angles.add((bond[1], bond[0], atom))
            for atom in self.bondedTo[bond[1]]:
                if atom != bond[0]:
                    if atom.index > bond[0].index:
                        unique_angles.add((bond[0], bond[1], atom))
                    else:
                        unique_angles.add((atom, bond[1], bond[0]))

        # sort angles by index of first atom
        unique_angles = sorted(list(unique_angles), key=lambda x: x[0].index)

        # add angles to topo object
        self.n_angles = 0
        for angle in unique_angles:
            self.angles[angle] = None #all angles have the same parameter in GaussianAnglePotential so no need extra params.
            self.n_angles += 1
            self.angles_indexes.append((angle[0].index, angle[1].index, angle[2].index))

    def getTorsions(self):
        """
        Reads bonds from topology, adds them to the main class and sorts them
        into a dictionary to store their forcefield properties.

        Torsion Angles are built from angles and bondedTo instance.
        This function modify :code:`self.torsions`, :code:`self.torsions_indexes` and :code:`self.n_torsions`
        """
        unique_torsions = set()
        for angle in self.angles:
            for atom in self.bondedTo[angle[0]]:
                if atom not in angle:
                    if atom.index < angle[2].index:
                        unique_torsions.add((atom, angle[0], angle[1], angle[2]))
                    else:
                        unique_torsions.add((angle[2], angle[1], angle[0], atom))

            for atom in self.bondedTo[angle[2]]:
                if atom not in angle:
                    """ 
                        it is stupid for checking atom.index as following line but it happens in all-atom model, when
                        chain of atoms my be branched. just keep it here.
                    """
                    if atom.index > angle[0].index:
                        unique_torsions.add((angle[0], angle[1], angle[2], atom))
                    else:
                        unique_torsions.add((atom, angle[2], angle[1], angle[0]))

        # sort dihedral angles by the first atom index
        unique_torsions = sorted(list(unique_torsions), key=lambda x: x[0].index)

        # add dihedral angle to topo object
        # topo model uses dihedral_params (from data/dihedral_params.csv) in addPeriodicTorsionForce; no residue eps_di
        self.n_torsions = 0
        for torsion in unique_torsions:
            self.torsions[torsion] = (None, None)
            self.n_torsions += 1
            self.torsions_indexes.append((torsion[0].index, torsion[1].index, torsion[2].index, torsion[3].index))

    """ Functions for setting force specific parameters """

    def setBondForceConstants(self) -> None:
        """
        Change the forcefield parameters for bonded terms.

        Set the harmonic bond constant force parameters. The input can be
        a float, to set the same parameter for all force interactions, or
        a list, to define a unique parameter for each force interaction.

        Parameters
        ----------

        Returns
        -------
        None
        """
        bond_force_constant = model_parameters.parameters[self.model]["bond_force_constant"]
        print(f"bond_force_constant: {bond_force_constant} kj/mol/nm^2")

        system._setParameters(self.bonds, bond_force_constant)

    def setParticlesMass(self, particles_mass):
        """
        Change the mass parameter for each atom in the system.

        Set the masses of the particles in the system. The input can be a
        float, to set the same mass for all particles, or a list, to define
        a unique mass for each particle.

        Parameters
        ----------
        particles_mass : float or list
            Mass(es) values to add for the particles in the TOPO system class.

        Returns
        -------
        None
        """

        self.particles_mass = particles_mass

    def setParticlesRadii(self, particles_radii):
        """
        Change the excluded volume radius parameter for each atom in the system.

        Set the radii of the particles in the system. The input can be a
        float, to set the same radius for all particles, or a list, to define
        a unique radius for each particle.

        Parameters
        ----------
        particles_radii : float or list
            Radii values to add for the particles in the TOPO system class.

        Returns
        -------
        None
        """

        self.rf_sigma = particles_radii

    def setParticlesCharge(self, particles_charge):
        """
        Set the charge of the particles in the system. The input can be a
        float, to set the same charge for all particles, or a list, to define
        a unique charge for each particle.

        Parameters
        ----------
        particles_charge : float or list
            Charge values to add for the particles in the TOPO system class.

        Returns
        -------
        None
        """

        self.particles_charge = particles_charge

    

    def setParticleTypeID(self, particle_id):
        self.particle_type_id = particle_id

    """ Functions for creating force objects with defined parameters """

    def addHarmonicBondForces(self) -> None:
        """
        Creates a harmonic bonded force term for each bond in the main
        class using their defined forcefield parameters.

        Creates an :code:`mm.HarmonicBondForce()` object with the bonds and
        parameters set up in the "bonds" dictionary attribute. The force object
        is stored at the :code:`harmonicBondForce` attribute.

        openMM uses harmonic bond that has energy term of form:

        .. math::
            E= \\frac{1}{2}k(r-r_0)^2

        The force parameters must be contained in self.bonds as follows:

        self.bonds is a dictionary:
            - The keys are 2-tuples for two atom items in :code:`self.topology.atoms` attribute.
            - The values are a 2-tuple of parameters in the following order:
                - first  -> bond0 (quantity)
                - second -> k (float) (measured in unit of kj/mol/nm^2)


        Returns
        -------
        None
        """

        self.harmonicBondForce = mm.HarmonicBondForce()
        for bond in self.bonds:
            self.harmonicBondForce.addBond(bond[0].index,
                                           bond[1].index,
                                           self.bonds[bond][0],
                                           self.bonds[bond][1])

    def addGaussianAngleForces(self) -> None:
        """
        Add Gaussian functional form of angle.
        Note that in openMM log is neutral logarithm.

        Angle potential take Gaussian functional form in hps-ss model.

        .. math::
            U_{angle}(\\theta) = \\frac{-1}{\gamma}
                \\ln{[e^{-\gamma[k_\\alpha( \\theta-\\theta_\\alpha)^2+\\epsilon_\\alpha]}
                +e^{-\\gamma k_\\beta(\\theta-\\theta_\\beta)^2}]}

        Angle potential is taken from reference:
        """

        gamma = 0.0239 / unit.kilojoule_per_mole  # 0.1 mol/kcal
        eps_alpha = 17.9912 * unit.kilojoule_per_mole  # 4.3 kcal/mol
        theta_alpha = 1.6 * unit.radian
        theta_beta = 2.27 * unit.radian
        k_alpha = 445.1776 * unit.kilojoule_per_mole / unit.radian ** 2 # 106.4 kcal/mol/rad^-2
        k_beta = 110.0392 * unit.kilojoule_per_mole / unit.radian ** 2 # 26.3 kcal/mol/rad^-2

        energy_function = '(-1 / gamma) * log(exp(-gamma * (k_alpha * (theta - theta_alpha) ^ 2 + eps_alpha)) ' \
                          '+ exp(-gamma * k_beta * (theta - theta_beta) ^ 2))'
        self.gaussianAngleForce = mm.CustomAngleForce(energy_function)
        self.gaussianAngleForce.addGlobalParameter('gamma', gamma)
        self.gaussianAngleForce.addGlobalParameter('eps_alpha', eps_alpha)
        self.gaussianAngleForce.addGlobalParameter('theta_alpha', theta_alpha)
        self.gaussianAngleForce.addGlobalParameter('theta_beta', theta_beta)
        self.gaussianAngleForce.addGlobalParameter('k_alpha', k_alpha)
        self.gaussianAngleForce.addGlobalParameter('k_beta', k_beta)

        for angle in self.angles:
            self.gaussianAngleForce.addAngle(angle[0].index, angle[1].index, angle[2].index)




    def addPeriodicTorsionForce(self) -> None:
        """
        Torsion potential in Ed's model, which is used periodic torsion angle.
        """

        # read the parameter for Periodic Torsion angle, which phase and force constant is depend on two middle residues type
        # print(f"current dir : {os.getcwd()}")

        dihedral_params = model_parameters.parameters[self.model]["dihedral_params"]
        # print(dihedral_params)

        self.periodicTorsionForce = mm.PeriodicTorsionForce()
        for torsion in self.torsions:
            # each torsion has 4 periodicity.
            for j in range(1, 5):
                delta_j = dihedral_params[str((str(torsion[1].residue.name), str(torsion[2].residue.name), j))][1]
                k_D_j = dihedral_params[str((str(torsion[1].residue.name), str(torsion[2].residue.name), j))][2]
                self.periodicTorsionForce.addTorsion(torsion[0].index, torsion[1].index, torsion[2].index, torsion[3].index,
                                                     j, delta_j, k_D_j)
                # print(f"{torsion[0].residue.name}, {torsion[1].residue.name}, {torsion[2].residue.name}, {torsion[3].residue.name}, {j}: {k_D_j:.6f}\t{delta_j:.6f}")


    def addYukawaForces(self, use_pbc: bool) -> None:
        """
        Creates a nonbonded force term for electrostatic interaction DH potential.

        Creates an :code:`mm.CustomNonbondedForce()` object with the parameters
        sigma and epsilon given to this method. The custom non-bonded force
        is initialized with the formula:

        .. math::
            energy = f \\times \\frac{q_1q_2}{\epsilon_r \\times r}\\times e^{(-r/lD)}


        where :math:`f=\\frac{1}{4\\pi\\epsilon_0}=138.935458` is the factor for short to convert dimensionless
        in calculation to :math:`kj.nm/(mol\\times e^2)` unit.

        :math:`\\epsilon_r=80`: Dielectric constant of water at 100mM mono-valent ion

        The force object is stored at the :code:`yukawaForce` attribute.

        Parameters
        ----------
        use_pbc: (bool) whether use PBC, cutoff periodic boundary condition

        Returns
        -------
        None
        """
        print("Setting Coulomb interaction ...")
        # currently, just use debye-length at [NaCl]=100mM
        lD = 1.0 * unit.nanometer
        electric_factor = 138.935458 * unit.kilojoule_per_mole * unit.nanometer / unit.elementary_charge ** 2
        yukawa_cutoff = 3.5 * unit.nanometer
        epsilon_r = 80.0

        energy_function = 'factor*charge1*charge2/epsilon_r/r*exp(-r/lD)'
        self.yukawaForce = mm.CustomNonbondedForce(energy_function)
        self.yukawaForce.addGlobalParameter('factor', electric_factor)
        self.yukawaForce.addGlobalParameter('epsilon_r', epsilon_r)
        self.yukawaForce.addGlobalParameter('lD', lD)
        self.yukawaForce.addPerParticleParameter('charge')
        if use_pbc:
            print("Set cutoff Periodic ...")
            self.yukawaForce.setNonbondedMethod(mm.NonbondedForce.CutoffPeriodic)
        else:
            print("Set cutoff NonPeriodic ...")
            self.yukawaForce.setNonbondedMethod(mm.NonbondedForce.CutoffNonPeriodic)

        print(f"Use cutoff distance: {yukawa_cutoff}")
        self.yukawaForce.setCutoffDistance(yukawa_cutoff)

        if isinstance(self.particles_charge, float):
            for i in np.arange(len(self.atoms)):
                self.yukawaForce.addParticle((self.particles_charge,))

        # in the case each atom has different sigma para.
        elif isinstance(self.particles_charge, list):
            assert self.n_atoms == len(self.particles_charge)
            for i, atom in enumerate(self.atoms):
                self.yukawaForce.addParticle((self.particles_charge[i],))

        # set exclusions rule
        bonded_exclusions = [(b[0].index, b[1].index) for b in list(self.topology.bonds())]
        self.yukawaForce.createExclusionsFromBonds(bonded_exclusions, self.bonded_exclusions_index)

   

    def addCustomNonBondedForce(self, distance_matrix, energy_matrix, use_pbc):
        """
        Add a custom non-bonded force to the system.
        """
        print("Adding custom non-bonded force...")
        table_R_ravel = distance_matrix.ravel().tolist()
        table_eps_ravel = energy_matrix.ravel().tolist()
        n_atoms = distance_matrix.shape[0]
        energy_function = 'eps*(13*(R/r)^12 - 18*(R/r)^10 + 4*(R/r)^6);'
        energy_function += 'eps = eps_table(id1, id2);'
        energy_function += 'R = R_table(id1, id2);'

        self.custom_non_bonded_force = mm.CustomNonbondedForce(energy_function)
        self.custom_non_bonded_force.addTabulatedFunction('eps_table', mm.Discrete2DFunction(n_atoms, n_atoms,
                                                                                        table_eps_ravel))
        self.custom_non_bonded_force.addTabulatedFunction('R_table', mm.Discrete2DFunction(n_atoms, n_atoms,
                                                                                        table_R_ravel))
        self.custom_non_bonded_force.addPerParticleParameter('id')
        for i, atom in enumerate(self.atoms):
            self.custom_non_bonded_force.addParticle((i,))

        self.custom_non_bonded_force.setNonbondedMethod(mm.NonbondedForce.CutoffPeriodic if use_pbc else mm.NonbondedForce.CutoffNonPeriodic)
        self.custom_non_bonded_force.setUseSwitchingFunction(True)
        self.custom_non_bonded_force.setSwitchingDistance(1.8 * unit.nanometer)
        self.custom_non_bonded_force.setCutoffDistance(2.0 * unit.nanometer)

        # set exclusion rule
        bonded_exclusions = [(b[0].index, b[1].index) for b in list(self.topology.bonds())]
        self.custom_non_bonded_force.createExclusionsFromBonds(bonded_exclusions, self.bonded_exclusions_index)
    

    """ Functions for creating OpenMM system object """

    def createSystemObject(self, check_bond_distances: bool = True, minimize: bool = False,
                           check_large_forces: bool = True, force_threshold: float = 10.0,
                           bond_threshold: float = 0.5) -> None:
        """
        Creates OpenMM system object adding particles, masses and forces.
        It also groups the added forces into Force-Groups for the hpsReporter
        class.

        Creates an :code:`mm.System()` object using the force field parameters
        given to the 'system' class. It adds particles, forces and
        creates a force group for each force object. Optionally the method
        can check for large bond distances (default) and minimize the atomic
        positions if large forces are found in any atom (default False).

        Parameters
        ----------
        minimize : boolean (False)
            Whether to minimize the system if large forces are found.
        check_bond_distances : boolean (True)
            Whether to check for large bond distances.
        check_large_forces : boolean (False)
            Whether to print force summary of force groups
        force_threshold : float (10.0)
            Threshold to check for large forces.
        bond_threshold : float (0.5)
            Threshold to check for large bond distances.

        Returns
        -------
        None
        """

        if check_bond_distances:
            # Check for large bond_distances
            self.checkBondDistances(threshold=bond_threshold)

        # Add particles to system
        self.addParticles()

        # Add created forces into the system
        self.addSystemForces()

        # Create force group for each added force
        for i, name in enumerate(self.forceGroups):
            self.forceGroups[name].setForceGroup(i)

        if minimize:
            check_large_forces = True

        if check_large_forces:
            # Check for high forces in atoms and minimize the system if necessary
            self.checkLargeForces(minimize=minimize, threshold=force_threshold)

    def checkBondDistances(self, threshold: float = 0.5) -> None:
        """
        Searches for large bond distances for the atom pairs defined in
        the 'bonds' attribute. It raises an error when large bonds are found.

        //TODO: threshold=0.5 is a safe threshold in protein system.
        In the presence of RNA, the equilibrium bond is set to 0.5 then will raise error there.

        Parameters
        ----------
        threshold : (float, default=0.5 nm)
            Threshold to check for large bond distances.

        Returns
        -------
        None
        """
        print('Checking large bonds in constructed model ...')
        if isinstance(threshold, float):
            threshold = threshold * unit.nanometer

        for b in self.bonds:
            if self.bonds[b][0] >= threshold:
                print('Problem with distance between atoms: ' + b[0].name + ' and ' + b[1].name)
                r1 = b[0].residue.name + '_' + str(b[0].residue.id)
                if b[0].residue == b[1].residue:
                    print('of residue: ' + r1)
                else:
                    r2 = b[1].residue.name + '_' + str(b[1].residue.id)
                    print('of residues: ' + r1 + ' and ' + r2 + ', respectively.')
                raise ValueError('The bond distance between them ' + str(self.bonds[b][0]) +
                                 'is larger than ' + str(threshold) + '. This error is caused when building model. '
                                                                      'Please report the error to the maintainer!')
            # else:
        print(f'All bonds seem to be OK (less than threshold: {threshold})')
        print('')

    def checkLargeForces(self, minimize: bool = False, threshold: float = 10) -> None:
        """
        Prints the topo system energies of the input configuration of the
        system. It optionally checks for large forces acting upon all
        particles in the topo system and iteratively minimizes the system
        configuration until no forces larger than a threshold are found.

        Parameters
        ----------
        threshold : (float, default=10)
            Threshold to check for large forces.
        minimize : (bool, default= False)
            Whether to iteratively minimize the system until all forces are lower or equal to
            the threshold value.

        Returns
        -------
        None
        """

        # minimized = False
        print('__________________________________________________________________')
        print('Potential Energy from initial structure (input structure):')

        # Define test simulation to extract forces
        integrator = mm.LangevinIntegrator(1 * unit.kelvin, 1 / unit.picosecond,
                                           0.0005 * unit.picoseconds)
        sim = mm.app.Simulation(self.topology, self.system, integrator)
        sim.context.setPositions(self.positions)
        state = sim.context.getState(getForces=True, getEnergy=True)

        # Print initial state of the system
        print(f'The Potential Energy of the system is : {state.getPotentialEnergy()}')
        for i, n in enumerate(self.forceGroups):
            energy = sim.context.getState(getEnergy=True, groups={i}).getPotentialEnergy().value_in_unit(
                unit.kilojoules_per_mole)
            print('The ' + n.replace('Force', 'Energy') + ' is: ' + str(energy) + ' kJ/mol')
        print('')

        # print(state.getForces())

        if minimize:
            print('__________________________________________________________________')
            print('Perform energy minimization ...')
            # Find if there is an acting force larger than threshold
            # minimize the system until forces have converged
            forces = [np.linalg.norm([f[0]._value, f[1]._value, f[2]._value]) for f in state.getForces()]
            # print(state.getForces())
            prev_force = None
            tolerance = 10

            while np.max(forces) > threshold:

                # Write atom with the largest force if not reported before
                if np.max(forces) != prev_force:
                    atom = self.atoms[np.argmax(forces)]
                    residue = atom.residue
                    print(f'Large force {np.max(forces):.3f} kJ/(mol nm) found in:')
                    print(f'Atom: {atom.index} {atom.name}')
                    print(f'Residue: {residue.name} {residue.index}')
                    print(f'Minimising system with energy tolerance of {tolerance:.1f} kJ/mol')
                    print('_______________________')
                    print('')

                sim.minimizeEnergy(tolerance=tolerance * unit.kilojoule / unit.mole)
                # minimized = True
                state = sim.context.getState(getForces=True)
                prev_force = np.max(forces)
                forces = [np.linalg.norm([f.x, f.y, f.z]) for f in state.getForces()]
                if tolerance > 1:
                    tolerance -= 1
                elif tolerance > 0.1:
                    tolerance -= 0.1
                elif tolerance == 0.1:
                    raise ValueError('The system could not be minimized at the requested convergence\n' +
                                     'Try to increase the force threshold value to achieve convergence.')

            print(f'All forces are less than {threshold:.2f} kJ/mol/nm')
            print('______________________')
            state = sim.context.getState(getPositions=True, getEnergy=True)
            print('Potential Energy After minimisation:')
            print(f'The Potential Energy of the system (after minimized) is : {state.getPotentialEnergy()}')
            for i, n in enumerate(self.forceGroups):
                energy = sim.context.getState(getEnergy=True, groups={i}).getPotentialEnergy().value_in_unit(
                    unit.kilojoules_per_mole)
                print('The ' + n.replace('Force', 'Energy') + ' is: ' + str(energy) + ' kJ/mol')

            print('')
            self.positions = state.getPositions()
            print('Saving minimized positions')
            print('__________________________________________________________________')
            print('')

    def addParticles(self) -> None:
        """
        Add particles to the system OpenMM class instance.

        Add a particle to the system for each atom in it. The mass
        of each particle is set up with the values in the :code:`particles_mass`
        attribute.

        """

        # Set same mass for each atom
        if isinstance(self.particles_mass, float):
            for i in np.arange(len(self.atoms)):
                self.system.addParticle(self.particles_mass)

        # Set unique masses for each atom
        if isinstance(self.particles_mass, list):
            assert len(self.particles_mass) == len(self.atoms)
            for i in np.arange(len(self.particles_mass)):
                self.system.addParticle(self.particles_mass[i])

    def addSystemForces(self) -> None:
        """
        Add forces to the system OpenMM class instance. It also save
        names for the added forces to include them in the reporter class.

        Adds generated forces to the system, also adding
        a force group to the :code:`forceGroups` attribute dictionary.

        """

        if self.harmonicBondForce is not None:
            self.system.addForce(self.harmonicBondForce)
            self.forceGroups['Harmonic Bond Energy'] = self.harmonicBondForce

        if self.gaussianAngleForce is not None:
            self.system.addForce(self.gaussianAngleForce)
            self.forceGroups['Gaussian Angle Energy'] = self.gaussianAngleForce

        if self.gaussianTorsionForce is not None:
            self.system.addForce(self.gaussianTorsionForce)
            self.forceGroups['Gaussian Torsion Energy'] = self.gaussianTorsionForce

        if self.periodicTorsionForce is not None:
            self.system.addForce(self.periodicTorsionForce)
            self.forceGroups['Periodic Torsion Energy'] = self.periodicTorsionForce

        if self.yukawaForce is not None:
            self.system.addForce(self.yukawaForce)
            self.forceGroups['Yukawa Energy'] = self.yukawaForce

        if self.ashbaugh_HatchForce is not None:
            self.system.addForce(self.ashbaugh_HatchForce)
            self.forceGroups['PairWise Energy'] = self.ashbaugh_HatchForce

        if self.wang_Frenkel_Force is not None:
            self.system.addForce(self.wang_Frenkel_Force)
            self.forceGroups['PairWire Energy'] = self.wang_Frenkel_Force
        
        if self.custom_non_bonded_force is not None:
            self.system.addForce(self.custom_non_bonded_force)
            self.forceGroups['Custom Non-Bonded Energy'] = self.custom_non_bonded_force

    def dumpStructure(self, output_file: str) -> None:
        """
        Writes a structure file of the system in its current state.

        Writes a PDB file containing the currently defined CG system atoms and its positions.

        Parameters
        ----------
        output_file : string
            name of the PDB output file.

        Returns
        -------
        None
        """

        self.structure.writeFile(self.topology, self.positions, file=open(output_file, 'w'))

    def dumpTopology(self, output_file: str) -> None:
        """
        Writes a topology file of the system in PSF format, this is used for visualization and post-analysis.

        Writes a file containing the current topology in the
        TOPO system. This file contains topology of system, used in visualization and analysis.

        Here, we used :code:`parmed` to load :code:`openMM topology` and :code:`openMM system` to create
        :code:`Structure` object in :code:`parmed`.
        Because parmed doesn't automatically recognize :code:`charge`, :code:`mass` of atoms by their name.
        We need to set :code:`charge`, :code:`mass` back to residues properties.

        Parameters
        ----------
        output_file : string [requires]
            name of the output PSF file.

        Returns
        -------
        None
        """

        top = pmd.openmm.load_topology(self.topology, self.system)
        for i, a in enumerate(top.atoms):
            a.mass, a.charge = self.particles_mass[i], self.particles_charge[i]

        """
        Parmed know exactly what chain is but it doesn't use to write psf. Instead, it writes segid (1-letter)
        to distinguish between segment, and PSF file does not has chain identifier.
        What we will do here is copy chain ID to segID so that Parmed can write a meaningful psf.
        """
        for r in top.residues:
            r.segid = r.chain
        top.save(f'{output_file}', overwrite=True)

    def dumpForceFieldData(self, output_file: str) -> None:
        """
        Writes to a file the parameters of the forcefield.

        Writes a file containing the current forcefield parameters in the
        CG system.

        Parameters
        ----------
        output_file : string [requires]
            name of the output file.

        Returns
        -------
        None
        """

        with open(output_file, 'w') as ff:

            ff.write('#### CG Force Field Parameters ####\n')
            ff.write('\n')
            if self.atoms != OrderedDict():
                ff.write('[atoms]\n')
                ff.write(
                    '# %2s %3s %9s %9s %9s \t %14s\n' % ('atom', 'mass', 'exc_radius', 'charge', 'hps', 'atom_name'))

                for i, atom in enumerate(self.atoms):

                    if isinstance(self.particles_mass, list):
                        mass = self.particles_mass[i]
                    elif isinstance(self.particles_mass, float):
                        mass = self.particles_mass
                    if isinstance(self.rf_sigma, list):
                        sigma = self.rf_sigma[i]
                    elif isinstance(self.rf_sigma, float):
                        sigma = self.rf_sigma
                    if isinstance(self.particles_charge, list):
                        charge = self.particles_charge[i]
                    elif isinstance(self.particles_charge, float):
                        charge = self.particles_charge
                    if isinstance(self.particles_hps, list):
                        hps = self.particles_hps[i]
                    elif isinstance(self.particles_hps, float):
                        hps = self.particles_hps
                    res = atom.residue

                    ff.write('%4s %5s %9.3f %9.3f %9.3f\t# %12s\n' % (atom.index + 1,
                                                                      mass,
                                                                      sigma,
                                                                      charge,
                                                                      hps,
                                                                      atom.name + '_' + res.name + '_' + str(
                                                                          res.index + 1)))
            if self.bonds != OrderedDict():
                ff.write('\n')
                ff.write('[bonds]\n')
                ff.write('# %2s %3s %-6s %-s \t\t self.bonds[bond][1] %12s %12s\n' % (
                    'at1', 'at2', 'b0', 'k', 'at1_name', 'at2_name'))
                for bond in self.bonds:
                    atom1 = bond[0]
                    atom2 = bond[1]
                    res1 = atom1.residue
                    res2 = atom2.residue
                    ff.write('%4s %4s %.4f %s \t# %12s %12s\n' % (atom1.index + 1,
                                                                  atom2.index + 1,
                                                                  self.bonds[bond][0]._value,
                                                                  self.bonds[bond][1],
                                                                  atom1.name + '_' + res1.name + '_' + str(
                                                                      res1.index + 1),
                                                                  atom2.name + '_' + res2.name + '_' + str(
                                                                      res2.index + 1)))

            if self.angles != OrderedDict():
                ff.write('\n')
                ff.write('[angles]\n')
                ff.write("header of angle\n")
                for angle in self.angles:
                    atom1 = angle[0]
                    atom2 = angle[1]
                    atom3 = angle[2]
                    ff.write(f"{atom1.index+1} {atom2.index+1} {atom3.index+1} #{atom1.name}_{atom1.residue.name}_{str(atom1.residue.index+1)},"
                             f"{atom2.name}_{atom2.residue.name}_{str(atom2.residue.index+1)} {atom3.name}_{atom3.residue.name}_{str(atom3.residue.index+1)}\n")

            if self.torsions != OrderedDict():
                ff.write('\n')
                ff.write('[torsions]\n')
                ff.write('header of torsions\n')
                for torsion in self.torsions:
                    atom1 = torsion[0]
                    atom2 = torsion[1]
                    atom3 = torsion[2]
                    atom4 = torsion[3]
                    ff.write(f"{atom1.index+1} {atom2.index+1} {atom3.index+1} {atom4.index+1}\n")


    def setCAMassPerResidueType(self):
        """
        Sets alpha carbon atoms to their average residue mass. Used specially for
        modifying alpha-carbon (CA) coarse-grained models.

        Sets the masses of the alpha carbon atoms to the average mass
        of its amino acid residue.

        Parameters
        ----------

        Returns
        -------
        None
        """
        # Load mass parameters from parameters package
        params = model_parameters.parameters[self.model]
        masses = []
        for r in self.topology.residues():
            if r.name in params:
                masses.append(params[r.name]['mass'])
            else:
                raise ValueError('Residue ' + r.name + ' not found in masses dictionary.')

        self.setParticlesMass(masses)

    def setCARadiusPerResidueType(self) -> None:
        """
        Sets alpha carbon atoms to their average residue mass. Used specially for
        modifying alpha-carbon (CA) coarse-grained models.

        Sets the excluded volume radii of the alpha carbon atoms
        to characteristic radii of their corresponding amino acid
        residue.

        Parameters
        ----------

        Returns
        -------
        None
        """

        # Load radii from parameters package
        params = model_parameters.parameters[self.model]

        radii = []

        for r in self.topology.residues():
            if r.name in params:
                radii.append(params[r.name]['radii'])
            else:
                raise ValueError('Residue ' + r.name + ' not found in radii dictionary.')

        self.setParticlesRadii(radii)

    def setCAChargePerResidueType(self) -> None:
        """
        Sets the charge of the alpha carbon atoms
        to characteristic charge of their corresponding amino acid
        residue.

        Parameters
        ----------

        Returns
        -------
        None
        """

        # Load charge from parameters package
        params = model_parameters.parameters[self.model]
        charge = []

        for r in self.topology.residues():
            if r.name in params:
                charge.append(params[r.name]['charge'])
            else:
                raise ValueError('Residue ' + r.name + ' not found in charge dictionary.')

        self.setParticlesCharge(charge)

    def setCAHPSPerResidueType(self) -> None:
        """
        Sets alpha carbon atoms to their residue hydropathy scale. Used specially for
        modifying alpha-carbon (CA) coarse-grained models.

        Sets the HPS model of the alpha carbon atoms using corresponding scale.

        Parameters
        ----------

        Returns
        -------
        None
        """

        # Load hydropathy scale from parameters package
        params = model_parameters.parameters[self.model]

        hps = []

        for r in self.topology.residues():
            if r.name in params:
                hps.append(params[r.name]['hps'])
            else:
                raise ValueError('Residue ' + r.name + ' not found in hps dictionary.')

        self.setParticlesHPS(hps)

    def setCAIDPerResidueType(self) -> None:
        """
        The mpipi model specified interactions are residue-specific, hence requires an extra particle identity.
        """
        params = model_parameters.parameters['mpipi']
        atom_type = []

        for r in self.topology.residues():
            if r.name in params:
                atom_type.append(params[r.name]['id'])
            else:
                raise ValueError(f'Residue {r.name} not found in model parameter')

        self.setParticleTypeID(atom_type)

    # User-hidden functions #
    @staticmethod
    def _setParameters(term, parameters):
        """
        General function to set up or change force field parameters.
        protected method, can be called only inside class system.

        Parameters
        ----------
        term : dict
            Dictionary object containing the set of degrees of freedom
            (DOF) to set up attributes to (e.g. :code:`bonds` attribute)

        parameters : integer or float or list
            Value(s) for the specific forcefield parameters. If integer
            or float, sets up the same value for all the DOF in terms.
            If a list is given, sets a unique parameter for each DOF.

        Returns
        -------
        None
        """

        if isinstance(parameters, int):
            parameters = float(parameters)

        # Set constant parameter for each item in FF term
        if isinstance(parameters, float):
            for item in term:
                """
                For example, use in set bond force constant:
                in the :code:`getBond()`, we set :code:`bond_length` to the first item of tuple, 
                so lack of bond force constant.
                In :code:`setBondForceConstants(8368.0)`: parameter passed is 8368.0, 
                :code:`setBondForceConstants(param)` calls to this function. Term is self.bonds, item looks like: 
                :code:`item: (<Atom 0 (CA) of chain 0 residue 0 (MET)>, <Atom 1 (CA) of chain 0 residue 1 (ASP)>)`
                :code:`term[item]` (before calling this function): :code:`(Quantity(value=0.382, unit=nanometer), None)`
                we take all values except the last (bond force constant which is currently :code:`None` = no parameters:
                :code:`(Quantity(value=0.382, unit=nanometer),)`: a tuple
                after calling this function:
                :code:`term[item]: (Quantity(value=0.382, unit=nanometer), 8368.0)`
                :code:`[tuple+tuple = tuple]`
                """
                term[item] = term[item][:-1] + (parameters,)

        # Set unique parameter for each item in FF term
        if isinstance(parameters, list):
            assert len(parameters) == len(list(term.keys()))
            for i, item in enumerate(term):
                term[item] = term[item][:-1] + (parameters[i],)


"""
End of class system. Happy simulating ...
"""
